from sqlalchemy import create_engine, MetaData, Table, text
from sqlalchemy.orm import sessionmaker
def init_ms_connection()():    
    engine,conn,error_message = None,None,None
    from sqlalchemy.engine import URL
    try:
        ms_username = "sa"
        ms_password = "Neodog2020"
        ms_server   = "192.168.10.190"
        ms_database = "mzkh"
        ms_driver   = "{ODBC Driver 17 for SQL Server}"

        connection_string = (
                f"DRIVER={ms_driver};"
                f"SERVER={ms_server};"
                f"DATABASE={ms_database};"
                f"UID={ms_username};"
                f"PWD={ms_password}"
            )
        
        #connection_string = "DRIVER={ODBC Driver 17 for SQL Server};SERVER=dagger;DATABASE=test;UID=user;PWD=password"
        connection_url = URL.create("mssql+pyodbc", query={"odbc_connect": connection_string})
        print(f"{connection_url}")        
        engine = create_engine(connection_url)
        conn = engine.connect()
    except Exception as e:
        error_message = str(e)
        print(error_message)
    return conn

def init_pg_connection():    
    engine,conn,error_message = None,None,None
    from sqlalchemy.engine import URL
    from sqlalchemy import create_engine
    try:
        #connection_url = f"postgresql://postgres:Neodog2020@192.168.10.21/mzkh"
        pg_username = "postgres"
        pg_password = "Neodog2020"
        pg_server   = "192.168.10.21"
        pg_database = "mzkh"
        pg_driver   = "postgresql"
        connection_url = f"{pg_driver}://{pg_username}:{pg_password}@{pg_server}/{pg_database}"
        print(f"{connection_url}")        
        engine = create_engine(connection_url)
        conn = engine.connect()
    except Exception as e:
        error_message = str(e)
        print(error_message)
    return conn

# Сопоставление типов данных MSSQL и PostgreSQL
type_mapping = {
    'INTEGER': 'INTEGER',
    'VARCHAR': 'VARCHAR',
    'NVARCHAR': 'TEXT',
    'DATETIME': 'TIMESTAMP',
    'FLOAT': 'FLOAT',
    'DECIMAL': 'DECIMAL',
    # Добавьте другие типы данных по мере необходимости
}

def convert_value(value, source_type):
    # Преобразование значений в соответствующий тип
    if source_type in type_mapping:
        return value  # Здесь можно добавить дополнительные преобразования, если необходимо
    return value  # Возвращаем значение без изменений, если тип не сопоставлен

def copy_table_data(ms_conn, pg_conn, table_name, set_identity=False, do_truncate=False, portion_size=1000):
    # Создаем сессии для источника и цели
    ms_session = sessionmaker(bind=ms_conn)()
    pg_session = sessionmaker(bind=pg_conn)()

    try:
        # Если do_truncate установлен в True, выполняем TRUNCATE TABLE
        if do_truncate:
            pg_session.execute(text(f"TRUNCATE TABLE {table_name} CASCADE;"))
            print(f"Таблица '{table_name}' была очищена с помощью TRUNCATE.")

        # Если set_identity установлен в True, изменяем столбец id
        if set_identity:
            pg_session.execute(text(f"ALTER TABLE {table_name} ALTER COLUMN id DROP IDENTITY;"))
            pg_session.execute(text(f"ALTER TABLE {table_name} ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;"))
            print(f"Столбец 'id' в таблице '{table_name}' изменен на GENERATED BY DEFAULT AS IDENTITY.")

        # Загружаем метаданные для источника
        metadata = MetaData()
        source_table = Table(table_name, metadata, autoload_with=ms_conn)

        # Получаем данные из источника
        query = ms_session.query(source_table)

        # Загружаем метаданные для цели
        target_metadata = MetaData()
        target_table = Table(table_name, target_metadata, autoload_with=pg_conn)

        # Счетчик для отслеживания вставленных записей
        record_count = 0

        # Вставляем данные в целевую таблицу порциями
        for portion in query.yield_per(portion_size):
            # Создаем словарь значений для вставки
            values = {column.name: convert_value(getattr(portion, column.name), str(column.type)) for column in source_table.columns}

            # Проверяем наличие 'id' и создаем оператор вставки
            if 'id' in values and not 'OBJECTID' in values:
                insert_stmt = text(f"INSERT INTO {target_table.name} (id, {', '.join(k for k in values.keys() if k != 'id')}) VALUES (:id, {', '.join([':%s' % k for k in values.keys() if k != 'id'])})")
                params = {'id': values['id']}
            else:
                insert_stmt = text(f"INSERT INTO {target_table.name} ({', '.join(k for k in values.keys())}) VALUES ({', '.join([':%s' % k for k in values.keys()])})")
                params = {k: v for k, v in values.items()}

            # Отладочный вывод
            print(f"Executing: {insert_stmt}, with values: {params}")

            # Передаем параметры как словарь
            pg_session.execute(insert_stmt, params)

            # Увеличиваем счетчик вставленных записей
            record_count += 1

            # Фиксируем изменения в целевой базе данных после каждой порции
            if record_count >= portion_size:
                pg_session.commit()
                print(f"Коммит выполнен для порции.")
                record_count = 0  # Сбрасываем счетчик после коммита

        # Фиксируем изменения в целевой базе данных после последней порции
        if record_count > 0:
            pg_session.commit()
            print(f"Коммит выполнен для оставшихся записей.")

        print(f"Данные из таблицы '{table_name}' успешно скопированы в PostgreSQL.")

    except Exception as e:
        print(f"Произошла ошибка: {e}")
        pg_session.rollback()
    finally:
        ms_session.close()
        pg_session.close()

# Пример использования:
# copy_table_data(ms_conn, pg_conn, 'your_table_name', set_identity=True, do_truncate=True, portion_size=1000)

ms_conn = init_ms_connection()
pg_conn = init_pg_connection()

# Предполагается, что функции copy_table_data и необходимые подключения ms_conn и pg_conn уже определены

# Список таблиц для копирования
tables_to_copy = [
    "mzkh_edizms",
    "mzkh_roles",
    "mzkh_orgs",
    "mzkh_datum_types",
    "mzkh_subsystems",
    "mzkh_files",
    "mzkh_options",
    "mzkh_users",
    "mzkh_datums",
    "mzkh_datum_values",
]
#tables_to_copy2 = [
#    "region",
#    "houses",
#    "namespace",
#    "housesparams",
#    "admhierarchy"  
# ]   
tables_to_copy2 = [
    "admhierarchy"  
 ]   
# Цикл по таблицам и вызов функции copy_table_data
for table_name in tables_to_copy:
    print(f"Копирование данных из таблицы: {table_name}")
    #copy_table_data(ms_conn, pg_conn, table_name, set_identity=True, do_truncate=True, portion_size=1000)

for table_name in tables_to_copy2:
    print(f"Копирование данных из таблицы: {table_name}")
    copy_table_data(ms_conn, pg_conn, table_name, set_identity=False, do_truncate=True, portion_size=3000)
